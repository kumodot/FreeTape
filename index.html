<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FreeTape Player</title>
  <style>
    :root {
      --button-row-offset: 1px;
      --label-y-offset: 5px;
      --textY: 0.29;  // Music Name Y Position
    }
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f4a261;
    }
    .player-frame {
      width: 615px; /* 123 x 5 */
      margin: 20px auto 0 auto;
      padding: 0;
      background-color: transparent;
      position: relative;
    }
    .button-row {
      width: 615px;
      display: flex;
      flex-direction: row;
      justify-content: flex-start;
      align-items: flex-start;
      gap: 0;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
      border: none;
      background: none;
    }
    .control-button {
      width: 123px;
      height: 91px;
      background-size: 123px 91px;
      background-repeat: no-repeat;
      background-position: center;
      background-color: transparent;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      cursor: pointer;
      padding: 0 !important;
      margin: 0 !important;
      box-sizing: border-box;
      appearance: none;
    }
    .button-label {
      position: absolute;
      bottom: var(--label-y-offset);
      left: 5px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 2px 4px;
      font-size: 12px;
      display: none;
    }
    #volumeContainer, #progressContainer {
      width: 615px;
      margin: 10px auto 0 auto;
      text-align: center;
      padding: 0;
    }
    #volumeControl, #progressSlider {
      width: 100%;
      margin: 0;
      display: block;
      box-sizing: border-box;
    }
    #status {
      text-align: center;
    }
    #cassetteCanvas {
      display: block;
      margin: 0 auto;
      /* Alinhado ao centro do container */
    }
  </style>
</head>
<body>
  <div class="player-frame">
    <canvas id="cassetteCanvas" width="615" height="414"></canvas>
    <div class="button-row">
      <button id="fileBtn"  class="control-button fileBtn"><span class="button-label">File</span></button>
      <button id="playBtn"  class="control-button playBtn"><span class="button-label">Play</span></button>
      <button id="stopBtn"  class="control-button stopBtn"><span class="button-label">Stop</span></button>
      <button id="prevBtn"  class="control-button prevBtn"><span class="button-label">Prev</span></button>
      <button id="nextBtn"  class="control-button nextBtn"><span class="button-label">Next</span></button>
    </div>
  </div>

  <div id="volumeContainer">
    <label>Vol:
      <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="1">
    </label>
  </div>
  <div id="progressContainer">
    <input type="file" id="fileInput" accept="audio/mp3" style="display:none">
    <input type="range" id="progressSlider" min="0" max="100" value="0">
    <p id="status">Status: Stopped</p>
  </div>

  <script>
    // ======== BG CONFIG ========
    let useLiveBg = false;
    const normalBgColor = '#f4a261';
    const liveBgColor   = '#ff00ff';
    function setBgColor() {
      document.body.style.backgroundColor = useLiveBg ? liveBgColor : normalBgColor;
    }
    setBgColor();
    // ==========================

    // Toggle UI
    let hideUI = false;

    // Flags
    const maxTrackLineLength = 40; // Pode ajustar como quiser!
    const showBackground = false;
    const showTrackLabel = true;
    const showTapeReels = true;
    const showButtonsLabels = false;
    const showStatus = false; // hide status by default
// Barra preta animada simulando a fita sobre o cabeçote
const tapeBar = {
  width: 310,        // largura em px
  thickness: 06,     // altura (grossura) da fita
  baseX: 0.5,        // centro X (0..1, fração da largura do canvas)
  baseY: 0.91,      // base Y (fração do height do canvas) -- ajuste como quiser!
  animAmplitude: 0.5,  // amplitude do movimento senoide (em px)
  playOffset: -3,    // offset em Y quando PLAY/Pause
  stopOffset: 0      // offset em Y quando Stop
};
let tapeBarAnimPhase = 0; // pode ser global, vai sincronizar com a rotação

    document.addEventListener('DOMContentLoaded', () => {
      if (!showBackground) document.querySelector('.player-frame').style.backgroundColor = 'transparent';
      document.querySelectorAll('.button-label').forEach(lbl => lbl.style.display = showButtonsLabels ? 'block' : 'none');
      document.getElementById('status').style.display = showStatus ? 'block' : 'none';
    });

    // ==== KEYBOARD SHORTCUTS ====
    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT') return;
      const key = e.key.toLowerCase();

      // U = Toggle UI (hide all controls except tape)
      if (key === 'u') {
        hideUI = !hideUI;
        document.querySelector('.button-row').style.display = hideUI ? 'none' : 'flex';
        document.getElementById('volumeContainer').style.display = hideUI ? 'none' : '';
        document.getElementById('progressContainer').style.display = hideUI ? 'none' : '';
        return;
      }
      // B = alterna BG magenta/normal
      if (key === 'b') {
        useLiveBg = !useLiveBg;
        setBgColor();
        return;
      }
      // = (igual) = volume up
      if (e.key === '=') {
        adjustVolume(0.05);
        return;
      }
      // - (menos) = volume down
      if (e.key === '-') {
        adjustVolume(-0.05);
        return;
      }
      // R ou seta esquerda = rewind
      if (key === 'r' || e.key === 'arrowleft') {
        document.getElementById('prevBtn').click();
        return;
      }
      // F ou seta direita = forward
      if (key === 'f' || e.key === 'arrowright') {
        document.getElementById('nextBtn').click();
        return;
      }
      switch(key) {
        case 'l': document.getElementById('fileBtn').click(); break;
        case 'p': document.getElementById('playBtn').click(); break;
        case 's': document.getElementById('stopBtn').click(); break;
      }
    });
    function adjustVolume(delta) {
      const vol = Math.max(0, Math.min(1, audio.volume + delta));
      audio.volume = vol;
      buttonSound.volume = vol;
      loadSound.volume   = vol;
      stopSound.volume   = vol;
      document.getElementById('volumeControl').value = vol;
    }
    // ============================

    // Sounds
    const buttonSound = new Audio('bt_press.wav');
    const loadSound   = new Audio('tape_load.wav');
    const stopSound   = new Audio('tape_stop.wav');
    const playSound = new Audio('play_sound.wav');
    const rwdSound = new Audio('rwd_sound.wav');
    const fwdSound = new Audio('fwd_sound.wav');

    // Audio player
    const audio = new Audio();
    let isPlaying = false;
    let isPausedState = false;
    let audioLoaded = false;
    let trackName = 'No Tape loaded';

    // Canvas
    const canvas = document.getElementById('cassetteCanvas');
    const ctx = canvas.getContext('2d');

    // Reel config
    const baseReelSize = 1.4;
    const ROT_INC = 0.04;
    const leftX = 0.305, rightX = 0.690, reelsY = 0.46;
    const maxReel = 90 * baseReelSize, minReel = 45 * baseReelSize, ringSize = 21 * baseReelSize;
    const textX = 0.5, textY = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--textY'));
    const wobbleI = 0.6, wobbleS = 0.005;
    const lPhase = Math.random() * 2 * Math.PI, rPhase = Math.random() * 2 * Math.PI;
    let angle = 0, animId;

    // Overlay
    const overlay = new Image(); overlay.src = './K7_Face_04B.png';
    let overlayLoaded = false;
    overlay.onload = () => { overlayLoaded = true; draw(); };

    // Button images map: idle, push, pause
    const btnMap = {
      fileBtn: ['bt01_idle.png','bt01_push.png'],
      playBtn: ['bt02_idle.png','bt02_push.png','pause.gif'],
      stopBtn: ['bt03_idle.png','bt03_push.png'],
      prevBtn: ['bt04_idle.png','bt04_push.png'],
      nextBtn: ['bt05_idle.png','bt05_push.png']
    };

    // Init buttons
    Object.entries(btnMap).forEach(([id, states]) => {
      const btn = document.getElementById(id);
      btn.style.backgroundImage = `url(${states[0]})`;
btn.addEventListener('mousedown', () => {
  // Só toca buttonSound para os botões normais
  if (id === 'playBtn') return;
  buttonSound.volume = audio.volume;
  loadSound.volume   = audio.volume;
  stopSound.volume   = audio.volume;
  btn.style.backgroundImage = `url(${states[1]})`;
  buttonSound.currentTime = 0;
  buttonSound.play();
});
      btn.addEventListener('mouseup', () => {
        btn.style.backgroundImage = `url(${states[0]})`;
      });
    });

    // Update visual states
    // Mantenha o updateStates assim:
function updateStates() {
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const [pIdle,pPush,pPause] = btnMap.playBtn;
  const [sIdle,sPush]        = btnMap.stopBtn;
  if (isPlaying) {
    playBtn.style.backgroundImage = `url(${pPush})`;
    stopBtn.style.backgroundImage = `url(${sIdle})`;
  } else if (isPausedState) {
    playBtn.style.backgroundImage = `url(${pPause})`;
    stopBtn.style.backgroundImage = `url(${sPush})`;
  } else {
    playBtn.style.backgroundImage = `url(${pIdle})`;
    stopBtn.style.backgroundImage = `url(${sPush})`;
  }
}

    // File load: reset to stopped state
    document.getElementById('fileInput').addEventListener('change', e => {
      const f = e.target.files[0];
      if (f) {
        audio.src = URL.createObjectURL(f);
        audioLoaded = true;
        loadSound.volume = audio.volume;
        loadSound.currentTime = 0;
        loadSound.play();
        trackName = f.name.replace(/\.[^/.]+$/, '');
        isPlaying = false;
        isPausedState = false;
        audio.pause();
        audio.currentTime = 0;
        document.getElementById('status').innerText = 'Status: Stopped';
        updateStates();
        draw();
      }
    });

    // Controls
    document.getElementById('fileBtn').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('playBtn').onclick = () => togglePlay();
    document.getElementById('stopBtn').onclick = () => stopAudio();
    document.getElementById('prevBtn').onclick = () => {
  if (audio.duration) {
    audio.currentTime = Math.max(0, audio.currentTime - 10);
    // Checa se está no início
    if (audio.currentTime === 0) {
      stopFromRewind();
    }
  }
};
    document.getElementById('nextBtn').onclick = () => { if (audio.duration) audio.currentTime = Math.min(audio.duration,audio.currentTime+10); };

    document.getElementById('volumeControl').oninput = e => {
      audio.volume = e.target.value;
      buttonSound.volume = audio.volume;
      loadSound.volume   = audio.volume;
      stopSound.volume   = audio.volume;
    };
    document.getElementById('progressSlider').oninput = e => { if (audio.duration) audio.currentTime = (e.target.value/100)*audio.duration; draw(); };
    audio.ontimeupdate = () => { if (audio.duration) document.getElementById('progressSlider').value = (audio.currentTime/audio.duration)*100; };

    audio.onended = () => {
      isPlaying = false;
      isPausedState = false;
      updateStates();
      cancelAnimationFrame(animId);
      document.getElementById('status').innerText = 'Status: Stopped';
      stopSound.volume = audio.volume;
      stopSound.currentTime = 0;
      stopSound.play();
      draw();
    };
    function splitTrackName(name, maxLen) {
  if (name.length <= maxLen) return [name];
  // Procura espaço antes do limite
  let idx = name.lastIndexOf(' ', maxLen);
  if (idx === -1) idx = maxLen; // Se não achar, quebra no limite mesmo
  return [name.slice(0, idx), name.slice(idx + 1)];
}
    function stopFromRewind() {
  // Traz o player para o estado pós-load
  isPlaying = false;
  isPausedState = false;
  document.getElementById('status').innerText = 'Status: Stopped';
  updateStates();
  cancelAnimationFrame(animId);
  stopSound.volume = audio.volume;
  stopSound.currentTime = 0;
  stopSound.play();
  draw();
}
    function togglePlay() {
  if (!audioLoaded) {
    document.getElementById('status').innerText = 'Status: No audio loaded';
    return;
  }
  if (isPlaying) {
    audio.pause();
    isPlaying = false;
    isPausedState = true;
    document.getElementById('status').innerText = 'Status: Paused';
    updateStates();
  } else {
    // Fita começa a girar imediatamente!
    isPlaying = true;
    isPausedState = false;
    document.getElementById('status').innerText = 'Status: Playing';
    draw();
    updateStates();

    // Decide se vai delay ou não:
    if (audio.currentTime < 0.05) {
      // Início da faixa: simula delay da fita real
      playSound.volume = audio.volume;
      playSound.currentTime = 0;
      playSound.play();

      let fadeDuration = 3000; // ms
      let fadeSteps = 24;
      let step = 0;
      let origVolume = playSound.volume;
      let fadeInterval = setInterval(() => {
        step++;
        playSound.volume = origVolume * (1 - step / fadeSteps);
        if (step >= fadeSteps) {
          playSound.volume = 0;
          clearInterval(fadeInterval);
        }
      }, fadeDuration / fadeSteps);

      setTimeout(() => {
        audio.play();
      }, 1000);
    } else {
      // Se está no meio, toca na hora (e playSound também)
      playSound.volume = audio.volume;
      playSound.currentTime = 0;
      playSound.play();
      audio.play();
    }
  }
}
    function stopAudio() {
  if (audioLoaded) {
    audio.pause();
    // NÃO VOLTA PRO INÍCIO!
    isPlaying = false;
    isPausedState = true;
    document.getElementById('status').innerText = 'Status: Stopped';
    updateStates();
    cancelAnimationFrame(animId);

    // CORTE imediato do som de play:
    playSound.pause(); 
    playSound.currentTime = 0;
    playSound.volume = 0;

    stopSound.volume = audio.volume;
    stopSound.currentTime = 0;
    stopSound.play();
    // NÃO zera barra de progresso
    draw();
  }
}

    // Draw function
    function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const t = Date.now()*wobbleS;
  const wL = Math.sin(t+lPhase)*wobbleI;
  const wR = Math.sin(t+rPhase)*wobbleI;
  const ratio = audio.duration ? audio.currentTime/audio.duration : 0;
  const lSize = maxReel - (maxReel-minReel)*ratio;
  const rSize = minReel + (maxReel-minReel)*ratio;
  if (showTapeReels) {
    drawReel(canvas.width*leftX + wL, canvas.height*reelsY, -angle, lSize);
    drawReel(canvas.width*rightX+ wR, canvas.height*reelsY, -angle, Math.max(rSize, ringSize));
  }

  // -------- Barra preta animada da fita (cabeçote) --------
  let barY = canvas.height * tapeBar.baseY;
  let reelIsMoving = isPlaying;
  let yAnim = 0;
  if (reelIsMoving) {
    tapeBarAnimPhase += 0.1;
    yAnim = Math.sin(tapeBarAnimPhase) * tapeBar.animAmplitude;
    barY += tapeBar.playOffset;
  } else {
    tapeBarAnimPhase = 0;
    yAnim = 0;
    barY += tapeBar.stopOffset;
  }
  ctx.save();
  ctx.fillStyle = 'black';
  ctx.globalAlpha = 0.87;
  ctx.fillRect(
    canvas.width * tapeBar.baseX - tapeBar.width/2,
    barY + yAnim,
    tapeBar.width,
    tapeBar.thickness
  );
  ctx.restore();

  // ----- overlay, track label etc...
  if (overlayLoaded) ctx.drawImage(overlay,0,0,canvas.width,canvas.height);
  if (showTrackLabel) {
  ctx.font = '20px Arial';
  ctx.fillStyle = 'black';
  ctx.textAlign = 'center';
  const lines = splitTrackName(trackName, maxTrackLineLength);
  // Ajusta Y: se tiver duas linhas, sobe metade da altura da linha (por exemplo 12px)
  let y = canvas.height * textY;
  if (lines.length > 1) y -= 12; // Ou ajuste para mais/menos
  ctx.fillText(lines[0], canvas.width*textX, y);
  if (lines[1]) ctx.fillText(lines[1], canvas.width*textX, y + 24);
}

  if (isPlaying) { angle+=ROT_INC; animId=requestAnimationFrame(draw); }
}



    // Reel drawing helpers
    function drawReel(x,y,a,s) { ctx.save(); ctx.translate(x,y); ctx.rotate(a);
      ctx.fillStyle='#f4a261'; ctx.beginPath(); ctx.arc(0,0,ringSize,0,2*Math.PI); ctx.fill();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(0,0,s,0,2*Math.PI); ctx.fill();
      drawReelRing(0,0); ctx.restore(); }
    function drawReelRing(x,y) { ctx.save(); ctx.translate(x,y);
      ctx.strokeStyle='white'; ctx.lineWidth=4.5; ctx.beginPath(); ctx.arc(0,0,ringSize,0,2*Math.PI); ctx.stroke();
      for(let i=0;i<6;i++){ const t=2*Math.PI/6*i; const oX=Math.cos(t)*ringSize, oY=Math.sin(t)*ringSize;
        const iX=Math.cos(t)*12*baseReelSize, iY=Math.sin(t)*12*baseReelSize;
        ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(oX,oY); ctx.lineTo(iX,iY); ctx.stroke(); }
      ctx.restore(); }
  </script>
</body>
</html>
